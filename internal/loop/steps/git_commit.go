package steps

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"github.com/chris/go_ralph/internal/agent"
)

// GitCommitConfig controls git commit behavior.
type GitCommitConfig struct {
	// Enabled toggles the step (default true)
	Enabled bool `json:"enabled,omitempty"`
	// RepoDir is the directory to run git commands in (default: ".")
	RepoDir string `json:"repo_dir,omitempty"`
	// MessageTemplate is used for commit message formatting.
	// Supported placeholders: {{task}}, {{timestamp}}
	MessageTemplate string `json:"message_template,omitempty"`
	// PrdFile is the prd.json path used to derive the current task for commit messages (default: "prd.json")
	PrdFile string `json:"prd_file,omitempty"`
	// FixPlanFile is used to derive the next task for commit messages (legacy, default: "")
	FixPlanFile string `json:"fix_plan_file,omitempty"`
	// CommitMessageFile is an optional file written by the agent containing subject + body.
	// If present and non-empty, it will be used via: git commit -F <file>.
	CommitMessageFile string `json:"commit_message_file,omitempty"`
}

// GitCommitStep stages and commits changes if there are any.
type GitCommitStep struct {
	name string
}

func NewGitCommitStep() *GitCommitStep {
	return &GitCommitStep{name: "git-commit"}
}

func (s *GitCommitStep) Name() string { return s.name }
func (s *GitCommitStep) Type() string { return "git-commit" }

func (s *GitCommitStep) Execute(ctx context.Context, rawConfig json.RawMessage) error {
	cfg := GitCommitConfig{
		Enabled:           true,
		RepoDir:           ".",
		MessageTemplate:   "{{task}}",
		PrdFile:           "prd.json",
		FixPlanFile:       "",
		CommitMessageFile: "commit_message.txt",
	}
	if rawConfig != nil && len(rawConfig) > 0 {
		if err := json.Unmarshal(rawConfig, &cfg); err != nil {
			return fmt.Errorf("failed to parse git-commit config: %w", err)
		}
	}
	if !cfg.Enabled {
		return nil
	}

	if _, err := exec.LookPath("git"); err != nil {
		return fmt.Errorf("git not found in PATH")
	}

	// Ensure we're in a git repo.
	if err := s.git(ctx, cfg.RepoDir, "rev-parse", "--is-inside-work-tree"); err != nil {
		// If not a repo, do nothing (best-effort)
		return nil
	}

	// Any changes?
	out, err := s.gitOutput(ctx, cfg.RepoDir, "status", "--porcelain")
	if err != nil {
		return err
	}
	if strings.TrimSpace(out) == "" {
		return nil
	}

	// Stage all changes.
	if err := s.git(ctx, cfg.RepoDir, "add", "-A"); err != nil {
		return err
	}

	task := "working"
	taskID := ""
	// Prefer prd.json for task info (current workflow).
	if cfg.PrdFile != "" {
		if prd, err := agent.LoadPRDStatus(cfg.PrdFile); err == nil && prd != nil {
			if prd.CurrentTask != "" {
				task = prd.CurrentTask
			}
			if prd.CurrentTaskID != "" {
				taskID = prd.CurrentTaskID
			}
		}
	}
	// Legacy fallback: @fix_plan.md
	if task == "working" && cfg.FixPlanFile != "" {
		if fix, err := agent.ParseFixPlan(filepath.Join(cfg.RepoDir, cfg.FixPlanFile)); err == nil {
			if fix != nil && fix.NextTask != "" {
				task = fix.NextTask
			}
		}
	}

	msg := cfg.MessageTemplate
	// If taskID is empty, best-effort strip common "{{task_id}}:" patterns.
	if strings.TrimSpace(taskID) == "" {
		msg = strings.ReplaceAll(msg, "{{task_id}}: ", "")
		msg = strings.ReplaceAll(msg, "{{task_id}}:", "")
		msg = strings.ReplaceAll(msg, "{{task_id}} ", "")
	}
	msg = strings.ReplaceAll(msg, "{{task_id}}", sanitizeOneLine(taskID))
	msg = strings.ReplaceAll(msg, "{{task}}", sanitizeOneLine(task))
	msg = strings.ReplaceAll(msg, "{{timestamp}}", time.Now().Format(time.RFC3339))
	msg = strings.TrimSpace(msg)
	if msg == "" {
		msg = "chore: progress"
	}

	commitMsgPath := filepath.Join(cfg.RepoDir, cfg.CommitMessageFile)
	if cfg.CommitMessageFile != "" {
		if b, err := os.ReadFile(commitMsgPath); err == nil {
			if strings.TrimSpace(string(b)) != "" {
				if err := s.git(ctx, cfg.RepoDir, "commit", "-F", commitMsgPath); err != nil {
					if strings.Contains(err.Error(), "nothing to commit") {
						return nil
					}
					return err
				}
				_ = os.Remove(commitMsgPath)
				return nil
			}
		}
	}

	// Default body for commits when no commit message file is provided.
	bodyLines := []string{
		"Generated by ralph.",
	}
	if strings.TrimSpace(taskID) != "" {
		bodyLines = append(bodyLines, "Task: "+strings.TrimSpace(taskID))
	}
	body := strings.Join(bodyLines, "\n")

	// Commit. If nothing to commit (race), just return nil.
	if err := s.git(ctx, cfg.RepoDir, "commit", "-m", msg, "-m", body); err != nil {
		if strings.Contains(err.Error(), "nothing to commit") {
			return nil
		}
		return err
	}

	return nil
}

func (s *GitCommitStep) git(ctx context.Context, dir string, args ...string) error {
	cmd := exec.CommandContext(ctx, "git", args...)
	cmd.Dir = dir
	var out bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &out
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("git %s failed: %w\nOutput: %s", strings.Join(args, " "), err, out.String())
	}
	return nil
}

func (s *GitCommitStep) gitOutput(ctx context.Context, dir string, args ...string) (string, error) {
	cmd := exec.CommandContext(ctx, "git", args...)
	cmd.Dir = dir
	b, err := cmd.CombinedOutput()
	if err != nil {
		return "", fmt.Errorf("git %s failed: %w\nOutput: %s", strings.Join(args, " "), err, string(b))
	}
	return string(b), nil
}

func sanitizeOneLine(s string) string {
	s = strings.ReplaceAll(s, "\n", " ")
	s = strings.ReplaceAll(s, "\r", " ")
	s = strings.TrimSpace(s)
	if s == "" {
		return "working"
	}
	return s
}
